---
layout: post
title: 待看
catalog: true
tags:
    - 算法
---
反转链表**

模板：   终止条件  递归方法，不要跳进递归，只假设递归最终的结果  基于递归最终的结果，再进行后续微调使得满足最终目的

递归反转整个链表   答案：    Step1：ListNode  last = reverse(head.next);解释：    如上图所示，reverse 函数会返回反转之后的头结点，我们用变量 last 接收了。              Step2：head.next.next  = head; 解释：    Step3：head.next =  null;（链表的末尾要指向 null）  return last;（递归反转之后，新的头结点是 last）解释：

反转链表前 N 个节点   结论代码：    结果    具体的区别：     1、base case 变为 n == 1，反转一个元素，就是它本身，同时要记录后驱节点。     2、刚才我们直接把  head.next 设置为 null，因为整个链表反转后原来的 head 变成了整个链表的最后一个节点。但现在 head 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 successor（第 n + 1 个节点），反转之后将 head 连接上。

反转链表的一部分     看不懂

**判定括号合法性**

单种括号     定义int：待匹配的左括号数量  遍历string的每个char，若为左括号，int++。若为右括号，int—。遍历过程中，若int为负数，结束遍历，返回false  若遍历完成，int为0，则返回true

多种括号        入栈：left.push(c)  获取栈顶元素：left.top()  出栈：left.pop()  遍历string的每个char，遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配。若匹配，出栈。若栈为空或者不匹配，直接返回false  若遍历完成，int为0，则返回true

非递归中序遍历

52张扑克牌少一张，找出缺失的一张（无脑遍历、求和

删除倒数第N个元素（ 链表

最小覆盖子串

旋转数组 找最小值

将一个 链表 向右旋转 k 个数

大顶堆或者小顶堆的插入时间复杂度是多少

二叉树的最大路径和

合并两个有序链表

一个一维数组，全是0和1，找最长的1子数组。

一个二维数组，找最大的1的矩阵。

两个乱序数组求交集（哈希）

实现一下LRU缓存机制

1、NC37 合并区间

2、NC52 括号序列

3、NC76 用两个栈实现队列

4、NC3 链表中环的入口节点

5、NC69 链表 中倒数第 k个结点

6、NC67 连续子数组的最大和

7、NC33 合并有序链表

8、NC136 输出二叉树的右视图

9、NC55 最长公共前缀

10、NC26括号生成

牛客题霸    1、NC25 删除有序链表中重复的元素

2、NC76 用两个栈实现队列

3、NC33 合并有序链表

4、NC52 括号序列

5、NC3 链表中环的入口节点

6、NC41 找到字符串的最长无重复字符子串

7、NC15 求二叉树的层序遍历

8、NC13 二叉树的最大深度

9、NC37 合并区间

10、NC55 最长公共前缀

11、NC4 判断链表中是否有环

12、NC57 反转数字

13、NC32 求平方根

LeetCode62 不同路径

LeetCode55 跳跃 游戏

NC4    判断链表中是否有环

2、NC22  合并两个有序的数组

3、NC105  二分查找

给一个整形数组，以及一个整形数字n，获取数组中那两个数字加起来等于结果n。

链表 合并：给出 n个有序的 链表 ，将他们合并为一个有序 链表 。

二叉树 找到任意节点间的最大路径

怎么得到树的最大深度

玩一个游戏：   1. 桌上有一堆石头，石头数为N  2. 两人交替取石头，每次可取1或2或3颗  3. 取到最后一颗石头的人胜  问：  已知石头数N，并且你先手，问你是否能赢？  1 <= n <= 10000

找出数组中第K大的数

链表 判断是否存在环

二叉树 的前序遍历，迭代实现

求数组中位数。

碰巧看过 Arrays.sort() 源码 ，回答了下传入的是 int[] 数组时的场景，较短（大概40多）时使用插入 排序 ，较长（大概接近300）时使用归并 排序 ，中间值使用双基线快排（ 算法 4有相关讲解

连续子数组最大和

链表 倒数第k个节点，k可能不合法

二叉树 层序遍历

一个random0()函数，p概率产生0，1-p概率产生1，实现等概率产生0和1

层次遍历、字典序打印

有序数组归并

自己实现队列的出队和入队，不使用集合的情况下。

算法题 ：判断循环 链表 的 入环的第一个节点

实现一个简单的 哈希表

之字打印

给定一个整数，判断它是否是回文数
