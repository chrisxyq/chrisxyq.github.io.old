---
layout: post
title: 分布式锁
catalog: true
tags:
    - Redis


---



| key value如何设计                                         |                                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| 如何防止释放别人的锁                                      |                                                              |
| 如何防止挂了锁还没有释放的情况                            |                                                              |
| 释放之前锁已经到期（守护线程）                            |                                                              |
| 主从模式，setnx分布式锁，会出现两个请求取到同一把锁的情况 | 主redis提供分布式锁，主机挂了，从redis成为主节点，从redis又提供了分布式锁   一致性要求比较高，可以使用ZK实现的分布式锁 |



原始代码：

![image-20210727140330920](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727140330920.png)

如上图所示，在多线程环境下会有原子性问题和虚假唤醒

### 使用jvm层面的单机版的锁，修饰以上代码块

注意到：synchronized是不见不散，容易导致线程积压、lock是过时不候（try lock，一定时间内抢不到锁就放弃

思考应该用哪一种

### redis分布式锁

![image-20210727153355231](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727153355231.png)

flag为false则抢锁失败，

#### 把delete方法解锁放到finally，即使抛异常也要释放锁

#### 为redis锁加过期时间，即使宕机也要释放锁

相当于是第二把保险，宕机之后，到了过期时间之后，redis依旧会释放锁

#### 加锁和为锁设置过期时间需要保证原子性

以下操作不是原子操作

![image-20210727160925791](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727160925791.png)

在加锁的同时，设置锁的过期时间，保证原子性

![image-20210727161132221](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727161132221.png)

#### 每个线程的分布式锁value不同：防止删除别人的锁

示意图

![image-20210727161613168](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727161613168.png)

保证删除的是自己的锁：redis分布式锁的设计：每个线程的value不同，key相同

![image-20210727161803181](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727161803181.png)

#### lua脚本：保证判断和删除锁动作的原子性

备注：使用redis事务替代lua脚本

![image-20210727164137776](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727164137776.png)

lua脚本保证原子性

![image-20210727164610180](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727164610180.png)

![image-20210727164631413](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727164631413.png)

#### redisson.getLock()分布式锁过期时间续期

#### redisson.getLock()防止异步复制造成锁丢失

（主节点还没把set的值同步给从节点，就挂了，redis为保证高可用，牺牲了数据的一致性

![image-20210727170604342](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727170604342.png)

