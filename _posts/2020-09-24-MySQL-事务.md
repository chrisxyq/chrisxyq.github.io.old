---
layout: post
title: 事务
catalog: true
tags:
    - MySQL


---

## 事务

### ACID

![1600948652157](https://gitee.com/chrisxyq/picgo/raw/master/img/1600948652157.png)

![1600948703642](https://gitee.com/chrisxyq/picgo/raw/master/img/1600948703642.png)



**事务的四种特性**

| 原子性 | 事务要么成功要么失败，由undolog保证，回滚则根据这个来        |
| ------ | ------------------------------------------------------------ |
| 隔离性 | 四种隔离级别，由锁来实现的                                   |
| 持久性 | 根据redolog实现，即使mysql挂了，也可以根据redolog持久化      |
| 一致性 | 以上三点是为了保障一致性，若出现异常需要回滚，而不是强行提交事务 |

**事务的隔离级别**

| 读未提交 | 脏读(由于读不加锁，写即使加锁也无法实现排他，但是读加锁会极大降低数据库性能) |
| -------- | ------------------------------------------------------------ |
| 读已提交 | 解决脏读，是根据mvcc多版本并发控制实现的，只有另一个事务提交之后，会产生新的版本号，才会读取新的版本的数据(但是会不可重复读，即读到其他事务修改的数据) |
| 可重复读 | 每次读的都是当前事务的版本的数据(innodb mvcc下，已解决幻读)   MySQL的默认事务隔离级别 |
| 串行化   | 在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争. |

**当前读与快照读**

|          | 快照读               | 当前读                                        |
| -------- | -------------------- | --------------------------------------------- |
| 举例     | 单条普通的select语句 | select for update  , insert,   update, delete |
| 实现方式 | mvcc+undolog         | 行锁+间隙锁                                   |

**什么是undolog?**

| 用处 | 1.历史恢复 通过undolog恢复之前版本的数据      2. 读老版本   根据条件读旧版本的数据 |
| ---- | ------------------------------------------------------------ |
| 划分 | 分为 insert undo_log 和 update undo_log      l  insert操作属于insert undo_log，只针对当前事务，在insert操作后产生undo_log记录，在事务提交后删除undo_log记录，说白了就是给当前事务自己看的.  l  update 和 delete操作属于update undo_log，会根据隔离级别不同事务版本的数据可见性不同 |

**什么是MVCC？(Multi-Version Concurrency Control, MVCC)**

版本存于undolog

读已提交:每次都获取log

可重复读:一个事务获取一次undolog

事务读数据的原则就是： 

l 读版本号小于等于当前版本的数据(意思就是读不到在当前事务之后修改的数据 避免了不可重复读)

l 读删除事务版本号大于等于当前版本的数据(意思就是如果这条数据在之后的事务里删了，当前事务也不能再读了) 

**MYSQL为什么选用InnoDB？**

l InnoDB支持事务，和行锁。

l InnoDB适合需要有事务操作的时候，也就是写多读少，MyISAM适合做读多写少的情况
