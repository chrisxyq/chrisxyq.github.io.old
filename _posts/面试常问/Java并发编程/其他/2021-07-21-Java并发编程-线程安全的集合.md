---
layout: post
title: Java并发编程-线程安全的集合
catalog: true
tags:
    - Java并发编程

---

[视频来源](https://www.bilibili.com/video/BV1Kw411Z7dF)

## ConcurrentModificationException

```java
public class ConcurrentModification {
    public static void main(String[] args) {
//        List<String> list = new CopyOnWriteArrayList<>();
//        List<String> list = Collections.synchronizedList(new ArrayList<>());
        List<String> list = new ArrayList();
        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
    }
```

```java
Exception in thread "22" java.util.ConcurrentModificationException
	at java.base/java.util.ArrayList$Itr.checkForComodification(ArrayList.java:1042)
```



## 面试题

### **为什么ConcurrentHashMap的get操作不需要加锁？**

由于Node的元素val和指针next是用volatile修饰的，

在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。

### **ConcurrentHashMap**

ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）

synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

|          | 7                                                            | 8                                                            |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据结构 | Segment 数组 +   HashEntry 数组 + 链表    每一个 Segment 是一个类似于 HashMap 的结构，所以每一个 HashMap 的内部可以进行扩容。但是 Segment 的个数一旦初始化就不能改变，  默认  Segment 的个数是 16 个，也可以认为  ConcurrentHashMap 默认支持最多 16 个线程并发 | Node 数组 + 链表 / 红黑树     Node 是类似于一个  HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表 |
| 机制     | 分段锁，                                                     | Synchronized 锁加   CAS                                      |

### **AtomicInteger 类如何保证原子性**

**CAS (compare and swap) + volatile 和 native 方法**来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。

| CAS   (compare and swap) | 拿期望的值和原本的一个值作比较，如果相同则更新成新的值。     |
| ------------------------ | ------------------------------------------------------------ |
| volatile                 | value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。 |
| native   方法            | UnSafe   类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。 |

### ConcurrentHashMap原理

JDK1.8 （上面有示意图）

ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）

synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。
