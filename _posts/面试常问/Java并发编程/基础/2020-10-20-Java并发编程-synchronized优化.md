---
layout: post
title: Java并发编程-synchronized优化
date:  2020-10-10
catalog: true
tags:
    - Java并发编程

---

| 分类                                     | 操作                 |
| ---------------------------------------- | -------------------- |
| synchronized 关键字自身的优化            | 锁膨胀和自适应自旋锁 |
| JVM 虚拟机对 synchronized 提供的优化方案 | 锁消除和锁粗化       |

## 锁膨胀

synchronized 的状态就多了无锁、偏向锁以及轻量级锁了，这时候在进行并发操作时，大部分的场景都不需要用户态到内核态的转换了，这样就大幅的提升了 

synchronized 的性能

| 场景                                                         | 锁                       | 细节流程                                                     | 好处                                                      |
| ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| 锁不存在多线程竞争，总是由同一线程多次获得的                 | 偏向锁（Biased Locking） | 当一个线程访问同步代码块并获取锁时，会在对象头的 Mark Word 里存储锁偏向的线程 ID，在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 Mark Word 里是否存储着指向当前线程的偏向锁，如果 Mark Word 中的线程 ID 和访问的线程 ID 一致，则可以直接进入同步块进行代码执行，如果线程 ID 不同，则使用 CAS 尝试获取锁，如果获取成功则进入同步块执行代码，否则会将锁的状态升级为轻量级锁。 | 偏向锁只需要在置换线程 ID 的时候执行一次 CAS 原子指令即可 |
| 1.多个线程竞争偏向锁时就会导致偏向锁升级为轻量级锁<br />2.线程交替执行同步块的情况 | 轻量级锁                 | 轻量级锁的获取和释放都通过 CAS 完成的，其中锁获取可能会通过一定次数的自旋来完成。 | 避免用户态和内核态的切换                                  |
| 如果同一时间多个线程同时访问同步代码块时，就会导致轻量级锁膨胀为重量级锁 | 重量级锁                 | 使用操作系统 Mutex Lock（互斥锁）<br /> synchronized 是依赖 Monitor 监视器锁实现的，而监视器锁又是依赖操作系统的互斥锁（Mutex Lock），互斥锁在每次获取和释放锁时，都会带来用户态和内核态的切换 |                                                           |

## 自适应自旋锁

自旋锁优点在于它避免一些线程的挂起和恢复操作，因为挂起线程和恢复线程都需要从用户态转入内核态，这个过程是比较慢的，所以通过自旋的方式可以一定程

度上避免线程挂起和恢复所造成的性能开销

线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数。简单来说，如果线程自旋成功了，则下

次自旋的次数会增多，如果失败，下次自旋的次数会减少。

---------

## 锁消除

指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。

锁消除的依据是逃逸分析的数据支持，如 StringBuffer 的 append() 方法，或 Vector 的 add() 方法，在很多情况下是可以进行锁消除的

```java
public String method() {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < 10; i++) {
        sb.append("i:" + i);
    }
    return sb.toString();
}
```

我们写的线程安全的加锁的 StringBuffer 对象，在生成字节码之后就被替换成了不加锁不安全的 StringBuilder 对象了，原因是 StringBuffer 的变量属于一个局部变

量，并且不会从该方法中逃逸出去，所以此时我们就可以使用锁消除（不加锁）来加速程序的运行。

## 锁粗化

如果检测到同一个对象执行了连续的加锁和解锁的操作，则会将这一系列操作合并成一个更大的锁，从而提升程序的执行效率。
