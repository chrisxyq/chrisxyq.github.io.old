---
layout: post
title: 场景题-分布式锁-init
date:  2022-10-10
catalog: true
tags:
    - 场景题

---



| 问题                                                      | 方案                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| key value如何设计                                         |                                                              |
| 如何防止释放别人的锁                                      |                                                              |
| 如何防止挂了锁还没有释放的情况                            |                                                              |
| 释放之前锁已经到期（守护线程）                            |                                                              |
| 如何处理大量失败请求                                      | 使用自旋锁：抢不到分布式锁的线程，不直接返回失败，给线程自旋时间<br />redisson就使用了自旋锁 |
| 锁重入问题                                                | 需要递归的业务场景，如递归获取树形结构<br />一般的redis锁不是可重入的，而redisson就使用了可重入锁 |
| 效率：读写锁问题                                          | redisson框架为例，它内部已经实现了读写锁的功能               |
| 效率：锁分段                                              | 为了提升系统性能，我们可以将库存分段，比如：分为100段，这样每段就有20个商品可以参与秒杀。<br/>在秒杀的过程中，先把用户id获取hash值，然后除以100取模。模为1的用户访问第1段库存，模为2的用户访问第2段库存，模为3的用户访问第3段库存，后面以此类推，到最后模为100的用户访问第100段库存。 |
| 主从模式，setnx分布式锁，会出现两个请求取到同一把锁的情况 | 主redis提供分布式锁，主机挂了，从redis成为主节点，从redis又提供了分布式锁   一致性要求比较高，可以使用ZK实现的分布式锁 |



### 使用jvm层面的单机版的锁，修饰以上代码块

```java
@RestController
public class IndexController {
    @Autowired
    private Redisson            redisson;
    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 单机锁会出现超卖现象
     *
     * @return
     */
    @RequestMapping("/deductStock")
    public String deductStock() {
        synchronized (this) {
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
            return "end";
        }
    }
```

注意到：synchronized是不见不散，容易导致线程积压、lock是过时不候（try lock，一定时间内抢不到锁就放弃

思考应该用哪一种

### redis分布式锁

```java
    /**
     * 考虑：单机锁超卖
     * 解决：使用redis分布式锁
     * setnx key value:当key已经存在。redis不做任何操作
     * redis为单线程的，抢到redis锁就执行业务代码
     * 抢不到redis锁就直接拒绝
     *
     * @return
     */
    @RequestMapping("/deductStock1")
    public String deductStock1() {
        String lockKey = "product001";
        //jedis.setnx(k,v);
        final Boolean res = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge");
        if (!res) {
            return "errorCode";
        }
        final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
        if (stock > 0) {
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + "");
            System.out.println("扣减成功，剩余库存：" + realStock);
        } else {
            System.out.println("扣减失败，库存不足");
        }
        stringRedisTemplate.delete(lockKey);
        return "end";
    }
```

### 异常宕机锁释放问题

#### 把delete方法解锁放到finally，即使抛异常也要释放锁

```java
    /**
     * 考虑：若拿到锁的线程在执行业务代码时，抛异常。则redis锁无法释放。
     * 导致后续线程在执行setIfAbsent时，res永远返回false
     * 则一直无法执行业务代码
     *  解决：try finally
     * @return
     */
    @RequestMapping("/deductStock2")
    public String deductStock2() {
        String lockKey = "product001";
        try{
            //jedis.setnx(k,v);
            final Boolean res = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge");
            if (!res) {
                return "errorCode";
            }
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        }finally {
            stringRedisTemplate.delete(lockKey);
        }
        return "end";
    }
```

#### 为redis锁加过期时间，即使宕机也要释放锁

相当于是第二把保险，宕机之后，到了过期时间之后，redis依旧会释放锁

```java
    /**
     * 考虑：机器宕机，依旧无法删除锁
     *  解决：为锁加过期时间
     * @return
     */
    @RequestMapping("/deductStock3")
    public String deductStock3() {
        String lockKey = "product001";
        try{
            //jedis.setnx(k,v);
            final Boolean res = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge");
            stringRedisTemplate.expire(lockKey,10, TimeUnit.SECONDS);
            if (!res) {
                return "errorCode";
            }
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        }finally {
            stringRedisTemplate.delete(lockKey);
        }
        return "end";
    }
```

### 锁过期时间问题&删除别人锁

#### 加锁和为锁设置过期时间需要保证原子性

```java
    /**
     * 考虑：获取锁和为锁加过期时间的操作不是原子操作
     *  解决：改为原子操作
     * @return
     */
    @RequestMapping("/deductStock4")
    public String deductStock4() {
        String lockKey = "product001";
        try{
            //jedis.setnx(k,v);
            final Boolean res = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge",10, TimeUnit.SECONDS);
            if (!res) {
                return "errorCode";
            }
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        }finally {
            stringRedisTemplate.delete(lockKey);
        }
        return "end";
    }
```

#### redisson.getLock()分布式锁过期时间续期&每个线程的分布式锁value不同：防止删除别人的锁

示意图

![image-20210727161613168](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210727161613168.png)

```java
  /**
     * 考虑：过期时间设置不合理
     * 过期时间设置过长：可能删除别人的锁：线程A执行完，finally删除了自己的锁，过了一会timeout开始删除锁（这时下一个线程可能还没执行完）
     * 
     *  解决：
     *  1.设置锁的value为uuid
     *  2.守护线程定时任务检查锁是否存在，如果存在，则延期
     *  或者使用redisson
     * @return
     */
    @RequestMapping("/deductStock5")
    public String deductStock5() {
        String lockKey = "product001";
        final String clientId = UUID.randomUUID().toString();
        try{
            //jedis.setnx(k,v);
            final Boolean res = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, "zhuge",10, TimeUnit.SECONDS);
            if (!res) {
                return "errorCode";
            }
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        }finally {
            if(clientId.equals(stringRedisTemplate.opsForValue().get(lockKey))){
                //确定是本线程的锁
                stringRedisTemplate.delete(lockKey);
            }
        }
        return "end";
    }
    /**
     * 考虑：过期时间设置不合理
     * 过期时间设置过长：可能删除别人的锁：线程A执行完，finally删除了自己的锁，过了一会timeout开始删除锁（这时下一个线程可能还没执行完）
     *
     *  解决：
     *  或者使用redisson
     *  获取不到redisson锁的线程自旋
     *  获取到redisson锁的线程，由守护线程自动续命
     lua脚本：保证判断和删除锁动作的原子性
     * @return
     */
    @RequestMapping("/deductStock6")
    public String deductStock6() {
        String lockKey = "product001";
        final RLock redissonLock = redisson.getLock(lockKey);
        try{
            redissonLock.lock();
            final int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        }finally {
            redissonLock.unlock();
        }
        return "end";
    }
```

还可使用TimerTask类续期



### 锁效率问题

#### 读写锁

```java
    /**
     * 在绝大多数实际业务场景中，一般是读数据的频率远远大于写数据。
     * 而线程间的并发读操作是并不涉及并发安全问题，我们没有必要给读操作加互斥锁，
     * 只要保证读写、写写并发操作上锁是互斥的就行，这样可以提升系统的性能。
     *
     * 读与读是共享的，不互斥
     * 读与写互斥
     * 写与写互斥
     *
     * @return
     */
    @RequestMapping("/deductStock7")
    public String deductStock7() {
        String lockKey = "product001";
        //读锁
        RReadWriteLock readWriteLock = redisson.getReadWriteLock(lockKey);
        RLock readLock = readWriteLock.readLock();
        try {
            readLock.lock();
            //业务操作
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            readLock.unlock();
        }
        //写锁
        RLock writeLock = readWriteLock.writeLock();
        try {
            writeLock.lock();
            //业务操作
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            writeLock.unlock();
        }
        return "end";
    }
```

#### 锁分段

### redisson.getLock()防止异步复制造成锁丢失

主节点还没把set的值同步给从节点，就挂了，redis为保证高可用，牺牲了数据的一致性

```java
    /**
     * 考虑：redis集群背景下，redis主节点还没把key同步给从节点，主节点就挂了
     * 由于redis的选举机制，从节点变成主节点，此时redis集群没有这个key，因此其他线程依旧可以获取锁
     * 会出现两个线程同时执行业务代码的情况
     *
     *  知识：CAP
     *  redis：单机上万QPS
     *  zookeeper:(半数节点同步成功，zookeeper才会获取锁成功)为了一致性，牺牲可用性
     *
     *  解决：Redlock：超过半数redis节点加锁成功，才算成功（其实少用，不推荐）
     *  此外：如何提升分布式锁的性能
     * @return
     */
```

