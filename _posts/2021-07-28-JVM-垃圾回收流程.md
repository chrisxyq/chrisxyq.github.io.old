---
layout: post
title: 垃圾回收流程
catalog: true
tags:
    - JVM

---



gc的时机

频繁老年代回收怎么分析解决？

频繁YOUNGGC怎么查问题

**2.** **full gc什么时候会出现，如果频繁full gc如何排查**

| Full gc原因 | Full gc基本上直接原因就是老年代空间不够了，最常见的情况就是E区S区的大小设置的不合理   l  old内存小于历次ygc流入的平均对象大小  l  ygc后S区也放不下 会进入Old  old也放不下 |
| ----------- | ------------------------------------------------------------ |
| Full gc排查 | top 命令查看系统 CPU 的占用情况   top –hp 进程id：复制该进程 id9，查看该进程的各个线程运行情况  jstack 命令查看线程 id 为 10 的线程为什么耗费 CPU 最高（将其线程 id 转换为十六进制）  第一步，通过jps获得java程序的pid  第二步，调用jinfo命令设置VM参数 |

**3.** **minorgc步骤**

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。

由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代

**4.** **String s = new String("abc")创建几个对象**

**5.** **new Object()的占多少字节**

**什么时候stw**

只有full gc才会发生stop the world，JVM引入了安全点(Safe Point)

**JVM调优示例**

jvm调优是为了调优gc，主要就是两个点，一个是减少Full gc的次数，一个是缩短一次Full gc的时间

我们完全可以把年轻代设置的大一些，minor gc的时候就把大对象回收

**!内存分配担保机制**

jvm判断一下你本次Minor GC发生以后，移动到老年代的对象会不会导致发生Full GC，JVM判断如果会，那就先进行Full GC 之后如果需要在进行Minor GC 这时候Minor GC 回收的内存空间会很少，甚至都不需要在进行Minor GC 可以提升一部分GC效率。

**!对象移动到老年代的情况**

| 对象年龄达到15                         | -XX:MaxTenuringThreshold                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| 大对象                                 | 大对象的定义可以通过参数-XX:PretenureSizeThreshold设置       |
| minor gc后survivor区装不下存活的对象了 | 老年代空间分配担保机制                                       |
| 动态年龄判断机制                       | 当survivor区中的对象从年龄为1开始，年龄1+年龄2+...+年龄n对象的综合占用survivor区的50%以上，那么年n以上的对象全部被移动到老年代。 |
