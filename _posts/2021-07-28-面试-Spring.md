---
layout: post
title: Spring
catalog: true
tags:
    - 面试

---

### spring如何获得上下文

#### WebApplicationUtils工具类	

ApplicationContext ap = WebApplicationUtils.getWebApplicationContext(servletContextParam)
依赖Servlet容器参数

#### ClassPathXmlApplicationContext类	

ApplicationContext ap = new ClassPathXmlApplicationContext("applicationContext.xml");
测试类用

#### 创建一个自己的工具类(SpringContextUtil)实现Spring的ApplicationContextAware接口

![image-20210728164550448](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210728164550448.png)

### **Spring 如何定义Bean**

### **@Component 和 @Bean 的区别**

|        | @Component | @Bean                                                        |
| ------ | ---------- | ------------------------------------------------------------ |
| 作用于 | 类         | 方法                                                         |
|        |            | 当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现 |

### **IOC如果不用配置文件，还可以怎么实现**

### **ioc初始化过程**

IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。

### **Bean的作用域**

|           | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| singleton |                                                              |
| prototype | 每次调用getBean方法，都将产生一个新的Bean实例                |
| request   | Web应用中使用Spring时，该作用域才有效   每个request内是单例的 |
| session   | Web应用中使用Spring时，该作用域才有效   每个session内（可能有多个request）是单例的 |





### **方法之间调用的事务传播机制**

MyISAM不支持事务

### **事务失效场景**

l 如果AOP使用了JDK动态代理，对象内部方法互相调用不会被Spring的AOP拦截，@Transactional注解无效。

l 如果AOP使用了CGLIB代理，事务方法或者类不是public，无法被外部包访问到，或者是final无法继承



### **Spring 中的 bean 生命周期?**

| 实例化 Instantiation  |      |
| --------------------- | ---- |
| 属性赋值 Populate     |      |
| 初始化 Initialization |      |
| 销毁 Destruction      |      |

构造方法，实例化对象

对象属性填充注入

Aop生成代理对象

将单例bean放到单例池

使用bean，调用destory方法

### **Bean的作用域**

|           | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| singleton |                                                              |
| prototype | 每次调用getBean方法，都将产生一个新的Bean实例                |
| request   | Web应用中使用Spring时，该作用域才有效   每个request内是单例的 |
| session   | Web应用中使用Spring时，该作用域才有效   每个session内（可能有多个request）是单例的 |

### **SpringMVC 工作原理**

| DispatcherServlet | 接收请求   调用 HandlerMapping，解析得到HandlerAdapter 适配器 |
| ----------------- | ------------------------------------------------------------ |
| HandlerAdapter    | 调用真正的处理器来处理请求，返回一个 ModelAndView 对象       |
| ViewResolver      | 根据逻辑 View 查找实际的   View                              |
| DispaterServlet   | 把返回的 Model 传给   View（视图渲染）。把 View 返回给请求者（浏览器） |

### **Spring 事务中哪几种事务传播行为?**

### **SpringBoot 自动装配？**

@SpringBootApplication包括以下三个注解

| @ComponentScan           | 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean |
| ------------------------ | ------------------------------------------------------------ |
| @Configuration           | 允许在上下文中注册额外的 bean 或导入其他配置类               |
| @EnableAutoConfiguration | 核心注解   自动装配核心功能的实现实际是通过AutoConfigurationImportSelector  类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中（所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到）  1.      判断spring.boot.enableautoconfiguration=true自动装配开关是否打开  2.      获取EnableAutoConfiguration注解中的 exclude 和 excludeName  3.      获取需要自动装配的所有配置类，读取META-INF/spring.factories  4.      筛选满足@ConditionalOnXXX 中的条件的类 |

### **Spring注解（前后端传值、读取配置、参数校验、异常处理）**

| Bean 的作用域                                  |                                                              | @Scope("singleton"，prototype，request，session)             |
| ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 前后端传值                                     | @PathVariable用于获取路径参数，                              | @GetMapping("/klasses/{klassId}/teachers")   public List<Teacher>  getKlassRelatedTeachers(            @PathVariable("klassId") Long klassId,            @RequestParam(value = "type", required = false) String type  ) |
| @RequestParam用于获取查询参数                  |                                                              |                                                              |
| @RequestBody                                   | 一个请求方法只可以有一个@RequestBody   读取  Request 请求的 body 部分并且Content-Type  为 application/json 格式的数据，自动将数据绑定到 Java 对象上 |                                                              |
| 读取配置信息                                   | @Value("${property}")                                        | 用于实体类属性                                               |
| @ConfigurationProperties(prefix =   "library") | 用于实体类                                                   |                                                              |
| 参数校验                                       | @Valid注解                                                   | spring-boot-starter-validation   依赖提供了常用的字段验证的注解  使用示例：  getPersonByID(@Valid @PathVariable("id") @Max(value = 5,message = "超过 id 的范围了") Integer id)  getPerson(@RequestBody @Valid Person person)  验证失败，它将抛出MethodArgumentNotValidException |
| 全局处理 Controller 层异常                     | @ControllerAdvice   :注解定义全局异常处理类  @ExceptionHandler  :注解声明异常处理方法 | 使用@ControllerAdvice自定义GlobalExceptionHandler，   在Handler类的方法使用@ExceptionHandler(MethodArgumentNotValidException.class)处理MethodArgumentNotValidException异常 |

**1.Spring事务的底层说一下**

Spring事务的本质 其实就是 AOP 和 数据库事务，Spring 将数据库的事务操作提取为 切面，通过AOP的方式 增强 事务方法

Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器

**Spring事务注解的rollback的参数说一下**

@Transactional注解默认会回滚运行时异常

解决：@Transactional(rollbackFor = Exception.class)

**如何解决：同一个类中出现两个带事务的方法调用，事务失效**



**2.Bean的加载过程（经典，多扯了点循环依赖的解决方式）**

**3.依赖注入的几种方式**

| 构造器注入 | 循环依赖无法解决，   只能抛出 BeanCurrentlyInCreationException 异常 |
| ---------- | ------------------------------------------------------------ |
| Set注入    | spring只能解决单例作用域的set注入的 bean 循环依赖            |



