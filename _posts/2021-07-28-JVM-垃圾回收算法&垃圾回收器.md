---
layout: post
title: 垃圾回收算法&垃圾回收器
catalog: true
tags:
    - JVM

---

## 垃圾回收算法

|              | 内容                                                         | 特点                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 复制算法     | 每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 | 适用于对象存活率低的场景，比如新生代，只有10% 的内存会被“浪费”。 |
| 标记清除算法 | 从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收 | 会产生大量不连续的内存碎片                                   |
| 标记整理算法 | 所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存   | 适用于对象存活率高的场景（老年代）                           |

### 标记阶段

#### 引用计数算法（python

![image-20210215003951929](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215003951929.png)

#### 可达性分析算法（根搜索算法、追踪性垃圾收集、java

有效解决引用计数算法中循环引用的问题，内容如下

##### 什么是gc roots

- 栈中引用的对象

  ![image-20210728155718098](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210728155718098.png)

- 方法区中的类静态属性/常量，引用的对象

  

  ![image-20210728155739833](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210728155739833.png)

- native方法引用的对象

  线程的start就是native方法（一个线程不能连续start两次）

  

![image-20210215211831925](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215211831925.png)

![image-20210215211903953](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215211903953.png)

可达性分析算法：类似于买葡萄时候的葡萄杆和散落的葡萄，可以认为散落的葡萄是垃圾

![image-20210215212330859](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215212330859.png)

通俗判断gc roots的方法：堆空间以外的元素，若指向/引用了堆内的对象，则该元素可以认为是gc roots

注意：以上表述指的是整个堆的垃圾回收时候的gc roots，若是伊甸园区的垃圾回收的gc roots，则伊甸园区以外的元素，若指向/引用了堆内的对象，则该元素可以认为是gc roots

![image-20210215212630524](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215212630524.png)

![image-20210215212700716](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210215212700716.png)

注意：

- 由于垃圾回收的时候，枚举根节点需要停顿，因此需要stop the world

- object 类有一个finalize方法，该方法一般不需要主动调用，由垃圾回收器调用，但是不可达的对象未必会被回收，由于对象可能会在finalize中复活，因此只有finalize调用过程中不被复活的不可达对象才会被垃圾回收

- 因此判断一个对象是否可回收，至少需要经过两次标记

  ![image-20210216092413100](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216092413100.png)

### 清除阶段

#### 标记清除算法

缺点：

效率不高，需要两次遍历才能完成垃圾回收（标记一次，清除一次。

且清理出的空间位置是空闲列表的方式，不连续，易产生内存碎片

![image-20210216094136219](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216094136219.png)

#### 复制算法：适用于新生代

复制算法示意图

![image-20210216095448100](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216095448100.png)

复制算法的缺点：

![image-20210216095757695](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216095757695.png)

使用场景：

适用于需要复制的对象不多的场景，如新生代的对象都是朝生夕死，死亡率较高，如新生代的两个幸存者survivor区域就是使用的复制算法

![image-20210216100316520](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216100316520.png)

#### 标记压缩算法：适用于老年代

对于老年代gc：大部分对象都是存活对象，由于存活对象较多，复制成本很高，因此不适合使用复制算法（此外，由于复制算法需要分出一半的空间出来，而老年代的空间默认为新生代空间的两倍，因此老年代若采用复制算法将造成空间浪费

而标记清除算法执行之后将产生内存碎片，因此也不适合老年代存放大对象的特性

执行过程如下：

![image-20210216101414446](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210216101414446.png)

标记压缩算法的优缺点

![image-20210217002626835](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210217002626835.png)

#### 三种算法的对比：分代收集算法

![image-20210217005016267](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210217005016267.png)

复制算法：适用于新生代的两个survivor区域，仅浪费了堆的1/3*1/10的内存

标记清除/标记整理：老年代

标记、清除、整理三个阶段的开销

![image-20210217112017309](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210217112017309.png)

### 增量收集算法

上述现有的算法在垃圾回收时，将导致stop the world，应用程序正常线程将被挂起

## 垃圾回收器

### 串行serial

客户离开餐桌，一个清洁工打扫

### 并行（默认）parallel（追求吞吐量）

客户离开餐桌，多个清洁工打扫

### 并发cms（concMarkSweep并发标记清除、追求低停顿、最短STW）

用户线程和垃圾回收线程可以同时执行（去一号桌吃饭，清扫二号桌）

-XX:+UseConcMarkSweepGC开启CMS后，新生代默认用parNew收集器组合使用、老年代使用serial Old（标记整理）作为备用垃圾收集器

四步如下

![image-20210728134627602](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210728134627602.png)

初始标记（STW）、并发标记（与用户线程并发）、重新标记（STW）、并发清除（与用户线程并发）

### G1（目标取代CMS）

相较于CMS提升：

采用标记整理算法，不会产生很多内存碎片

最多可以设置2048个区域，每个区域不再从物理上严格区分新生代养老代

STW更可控：用户可以指定期望的STW时间

垃圾回收的四步过程和CMS相同
