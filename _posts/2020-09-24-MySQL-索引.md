---
layout: post
title: 索引
catalog: true
tags:
    - MySQL

---

## 索引

### sql语句分析及创建索引：explain和create

![1601025144066](https://gitee.com/chrisxyq/picgo/raw/master/img/1601025144066.png)

### 红黑树比平衡二叉树好在哪里\在什么场景会用到红黑树，为什么它们要用红黑树

AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。所以当你的应用涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；
Java中TreeSet，TreeMap的底层都是基于RedBlackTree红黑树的；



   b+数一般有几层
1-3层，约 2 千万行数据。
b+树节点什么时候考虑分裂，一个节点能存多少数据？

假设要查一个非主键索引，是怎么查的？

**sql：用户表、订单表连表查询，取最近10个订单；内连接用户表、订单表两张表都很大怎么操作？**

回表是什么？

**索引数据结构**

|          | B树                                                          | B+树                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据结构 | 有序数组+平衡多叉树                                          | 有序数组链表+平衡多叉树   根节点到每个叶子节点高度差不超过1  关键字全部存放在叶子节点中，非叶子节点用来做索引，  叶子节点之间有双向指针 |
| 元素遍历 | B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题，B树必须用中序遍历的方法按序扫库 | B+树直接从叶子结点挨个扫一遍就完了                           |
| 区间访问 | B树不支持                                                    | 提高区间访问的性能，B+树支持range-query                      |

**索引类型**

普通索引（key），唯一索引（unique key），主键索引（primary key），全文索引（fulltext key）

复合索引：多个字段增加索引，遵循最左原则，比如创建索引(col1 + col2 + col3)，相当于创建了(col1)、(col1,col2)、(col,col2,col3)三个索引。

**主键，唯一索引区别**

|                | 主键                       | 唯一索引                   |
| -------------- | -------------------------- | -------------------------- |
| 是什么         | 约束                       | 是表的冗余数据结构         |
| 表可以有几个   | 一个                       | 可以有多个                 |
| 是否可当做外键 | 可                         | 不可                       |
| 充分必要条件   | 主键一定会创建一个唯一索引 | 有唯一索引的列不一定是主键 |

**执行计划**

Id:sql里面有几个select就几个id

Type：优化sql的重要字段

执行效率：all<index<range<ref<eq_ref<const<system

index：遍历索引树（遍历所有索引）

all：全表扫描

![img](https://pic1.zhimg.com/v2-4f89913ab376925632be5823a038f938_b.png)

**聚簇索引&非聚簇索引**

|      | 聚簇索引                                                     | 非聚簇索引                                                   |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|      | 数据存储与索引放到了一块，   索引结构的叶子节点保存了行数据  | 将数据与索引分开存储，   索引结构的叶子节点存放的是数据行的地址 |
|      | Innodb主键一定是聚簇索引，建议使用int自增作为主键   Myisam没有聚簇索引 |                                                              |
|      | 范围查询效率高，适合排序                                     |                                                              |

**索引失效场景**

| 场景                                                         | 举例                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| like查询，不能以通配符开头                                   | SELECT * FROM T1 WHERE NAME LIKE   ‘%L%’  SELECT * FROM T1 WHERE  SUBSTING(NAME,2,1)=’L’  SELECT * FROM T1 WHERE NAME LIKE ‘L%’     即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作 |
| 复合索引只对第一个字段有效                                   | 建立复合索引：   alter table person add  index(first_name,last_name);  其原理就是将索引先按照从first_name中提取的关键字排序，如果无法确定先后再按照从last_name提取的关键字排序，也就是说该索引表只是按照记录的first_name字段值有序。  因此select * from person where first_name =  ?是可以利用索引的，而select * from person where last_name = ?无法利用索引。     复合索引的应用场景：组合查询  比如对于select * person from first_name = ?  and last_name = ?，复合索引就比对first_name和last_name单独建立索引要高效些。  复合索引首先二分查找与first_name = ?匹配的记录，再在这些记录中二分查找与last_name匹配的记录，只涉及到一张索引表。而分别单独建立索引则是在first_name索引表中二分找出与first_name = ?匹配的记录，再在last_name索引表中二分找出与last_name = ?的记录，两者取交集。 |
| 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算 |                                                              |
| in 和 not in 也要慎用                                        | 对于连续的数值，能用 between 就不要用 in 了：   select id from t where num between 1 and 3 |
| 避免在 where 子句中使用!=或<>操作符                          |                                                              |
| 避免在 where 子句中对字段进行   null 值判断                  |                                                              |
| 索引数据重复率太高会导致全表扫描   状态值，不容易使用到索引  | 如性别、支付状态等状态值字段往往只有极少的几种取值可能，这种字段即使建立索引，也往往利用不上。这是因为，一个状态值可能匹配大量的记录，这种情况MySQL会认为利用索引比全表扫描的效率低，从而弃用索引。索引是随机访问磁盘，而全表扫描是顺序访问磁盘 |
| or，两边条件都有索引可用                                     | 一旦有一边无索引可用就会导致整个SQL语句的全表扫描            |
