---
layout: post
title: JDK 动态代理& CGLIB 动态代理
catalog: true
tags:
    - Java SE
---


## JDK 动态代理& CGLIB 动态代理

动态代理是在运行时动态生成类字节码，并加载到 JVM 中的，

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

|                              | JDK 动态代理                                                 | CGLIB 动态代理                                               |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代理对象                     | 只能代理实现了接口的类或者直接代理接口                       | 可以代理未实现任何接口的类   CGLIB(Code  Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成 |
| 核心原理                     | InvocationHandler 接口和 Proxy 类是核心                      | MethodInterceptor 接口和 Enhancer 类是核心                   |
| 使用步骤1：自定义方法拦截器 | JDK:    自定义方法拦截器InvocationHandler   并重写invoke方法： | CGLIB :自定义方法拦截器MethodInterceptor 并重写 intercept 方法 |
| 使用步骤2： 获取代理对象   | JDK: 通过   Proxy.newProxyInstance(ClassLoader loader,Class<?>[]  interfaces,InvocationHandler h) 方法创建代理对象； | CGLIB : 通过 Enhancer 类的 create()创建代理类；             |
| 备注                         | invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。 | 通过生成一个被代理类的子类来拦截被代理类的方法调用，   因此不能代理声明为 final 类型的类和方法 |



|                                |                                                              |
| ------------------------------ | ------------------------------------------------------------ |
| JDK（Spring AOP 运行时增强）   | 接口，用Proxy.newProxyInstance生成代理对象，InvocationHandler |
| CGLIB（Spring AOP 运行时增强） | 用enhancer生成代理对象，MethodInteceptor   如果目标对象实现了接口，可以强制使用CGLIB实现AOP |
| AspectJ （编译时增强           | 切面太多的话，最好选择 AspectJ ，它比Spring   AOP 快很多     |

## JDK 动态代理

###  自定义方法拦截器InvocationHandler   并重写invoke方法

```java
public class TargetInvoker implements InvocationHandler {
    // 代理中持有的目标类
    private Object target;

    /**
     * proxy 代理目标对象的代理对象，它是真实的代理对象。
     * method 执行目标类的方法
     * args 执行目标类的方法的参数
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("jdk 代理执行前");
        Object result = method.invoke(target, args);
        System.out.println("jdk 代理执行后");
        return result;
    }
```



### 通过   Proxy.newProxyInstance(ClassLoader loader,Class<?>[]  interfaces,InvocationHandler h) 方法创建代理对象

```java
public class DynamicProxyAnimal {
    /**
     * 通过调用java.lang.reflect.Proxy #newProxyInstance静态方法创建代理对象
     *
     * @param target
     * @return
     * @throws Exception
     */
    public static Object getProxy(Object target) throws Exception {
        Object proxy = Proxy.newProxyInstance(
                target.getClass().getClassLoader(), // 指定目标类的类加载
                target.getClass().getInterfaces(),  // 代理需要实现的接口，可指定多个，这是一个数组
                new TargetInvoker(target)   // 代理对象处理器
        );
        return proxy;
    }
```



### demo测试

```java
    /**
     *  JDK 动态代理是通过实现目标类的接口，然后将目标类在构造动态代理时作为参数传入，使代理对象持有目标对象，
     *  再通过代理对象的 InvocationHandler 实现动态代理的操作。
     * @throws Exception
     */
    @Test
    public void dynamicProxy() throws Exception {
        Cat cat = new Cat();
        Animal proxy = (Animal) DynamicProxyAnimal.getProxy(cat);
        proxy.call();
    }
```



## CGLIB 动态代理

### 自定义方法拦截器MethodInterceptor 并重写 intercept 方法

```java
/**
 * 首先方法拦截接口 net.sf.cglib.proxy.MethodInterceptor
 */
public class TargetInterceptor implements MethodInterceptor {
    /**
     * obj 代理类对象
     * method 当前被代理拦截的方法
     * args 拦截方法的参数
     * proxy 代理类对应目标类的代理方法
     */
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("CGLIB 调用前");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("CGLIB 调用后");
        return result;
    }
```



### 通过 Enhancer 类的 create()创建代理类

```java
public class CglibProxy {

    public static Object getProxy(Class<?> clazz){
        Enhancer enhancer = new Enhancer();
        // 设置类加载
        enhancer.setClassLoader(clazz.getClassLoader());
        // 设置被代理类
        enhancer.setSuperclass(clazz);
        // 设置方法拦截器
        enhancer.setCallback(new TargetInterceptor());
        // 创建代理类
        return enhancer.create();
    }
```



### demo测试

```java
    /**
     *  CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。
     *  当调用代理方法时，通过拦截方法的方式实现代理的操作。
     *  总的来说，JDK 动态代理利用接口实现代理，CGLIB 动态代理利用继承的方式实现代理。
     * @throws Exception
     */
    @Test
    public void dynamicProxy() throws Exception {
        Cat cat = (Cat) CglibProxy.getProxy(Cat.class);
        cat.hobby();
    }
```



## CGLIB 动态代理的回调过滤器 CallbackFilter

作用：针对不同的方法，调用不同的方法拦截器

### 编写回调过滤器 CallbackFilter

```java
/**
 * 回调过滤器 CallbackFilter
 * TargetCallbackFilter#accept返回的数字即为该数组的索引，决定调用的回调选择器。
 */
public class TargetCallbackFilter implements CallbackFilter {
    @Override
    public int accept(Method method) {
        if ("hobby".equals(method.getName())) {
            return 1;
        } else {
            return 0;
        }
    }
}
```



### 通过 Enhancer 类的 create()创建代理类

```java
public class CglibProxy {
    /**
     * 为演示调用不同的方法拦截器，在 Enhancer 设置中，
     * 使用Enhancer#setCallbacks设置多个方法拦截器，参数是一个数组，
     * TargetCallbackFilter#accept返回的数字即为该数组的索引，决定调用的回调选择器。
     * @param clazz
     * @return
     */
    public static Object getProxy(Class<?> clazz){
        Enhancer enhancer = new Enhancer();
        enhancer.setClassLoader(clazz.getClassLoader());
        enhancer.setSuperclass(clazz);
        enhancer.setCallbacks(new Callback[]{new TargetInterceptor(), new TargetInterceptor2()});
        enhancer.setCallbackFilter(new TargetCallbackFilter());
        return enhancer.create();
    }
```



### demo测试

```java
    /**
     *  CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。
     *  当调用代理方法时，通过拦截方法的方式实现代理的操作。
     *  CGLIB 动态代理不能代理 final 修饰的类和方法
     *  总的来说，JDK 动态代理利用接口实现代理，CGLIB 动态代理利用继承的方式实现代理。
     * @throws Exception
     */
    @Test
    public void dynamicProxy() throws Exception {
        Cat cat = (Cat) CglibProxy.getProxy(Cat.class);
        cat.call();
        cat.hobby();
    }
```

