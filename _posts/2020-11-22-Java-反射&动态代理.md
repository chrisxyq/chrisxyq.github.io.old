---
layout: post
title: 反射&动态代理
catalog: true
tags:
    - Java
---
# Class类的理解&类的加载过程&运行时类

类的加载过程：编译生成字节码文件，对字节码文件解释运行，将字节码文件加载到内存

运行时类：加载到内存中的类

Class类的实例：运行时类

![1606055589616](https://gitee.com/chrisxyq/picgo/raw/master/img/1606055589616.png)

# 获取Class实例的三种方式

| 知道具体类的情况下可以使用                              | Class alunbarClass = TargetObject.class;                     |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| 通过 Class.forName()传入类的路径获取                    | Class alunbarClass1 =   Class.forName("cn.javaguide.TargetObject"); |
| 通过对象实例   instance.getClass()获取                  | TargetObject o = new TargetObject();   Class alunbarClass2 = o.getClass(); |
| 通过类加载器   xxxClassLoader.loadClass()传入类路径获取 | Class clazz =   ClassLoader.loadClass("cn.javaguide.TargetObject"); |

![1606057739213](https://gitee.com/chrisxyq/picgo/raw/master/img/1606057739213.png)

![1606058012058](https://gitee.com/chrisxyq/picgo/raw/master/img/1606058012058.png)

加载到内存的运行时类会缓存一段时间，以上三种方式获取的运行时类是同一个，即==为true

因此，标题取为如何获取，而不是如何创建

以上四种方式评价：

方式1：编译期便已经写死，一旦写错则编译会报错，不常用

方式2：需要有类的对象，不常用

方式3：运行时才会报错，体现了反射的动态性，常用

方式4：不常用

# 创建运行时类的对象



# 调用运行时类的指定结构

# 反射

使用javabean空参构造器构造对象

封装性解决的是建议怎么调用的问题

反射解决的是能不能调用的问题

反射：当编译时候不能确定造哪个类的对象，使用反射。如后台运行时，接收不同的url请求，造不同的对象。

反射的源头：java.lang.Class类的对象

注意：要创建一个Class的实例，不能new Class，Class的实例应该是运行时类。如

调用运行时类的属性

Class clazz=Person.class

![1596208632495](https://gitee.com/chrisxyq/picgo/raw/master/img/1596208632495.png)

## 获取Class实例

获取Class实例是实现反射的第一步，有四种方法获取Class实例

![1596254286946](https://gitee.com/chrisxyq/picgo/raw/master/img/1596254286946.png)



## 通过classloader加载配置文件

![1596258489168](https://gitee.com/chrisxyq/picgo/raw/master/img/1596258489168.png)



## 创建运行时类的对象

反射是体现语言动态性的关键

使用Class类的forname(全类名)的方法创建运行时类

使用运行时类的newInstance方法创建运行时类的对象

![1596269326406](https://gitee.com/chrisxyq/picgo/raw/master/img/1596269326406.png)



## 调用运行时类的对象的指定属性/方法

getDeclaredField()

![1596270119751](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270119751.png)

调用运行时类的对象的非静态方法

Class clazz=Person.class；

![1596270558829](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270558829.png)

调用运行时类的对象的静态方法：任意对象均可

![1596270859641](https://gitee.com/chrisxyq/picgo/raw/master/img/1596270859641.png)

# 动态代理

AOP:动态代理

静态代理和动态代理的区别是：代理本身是编译时确定还是运行时动态创建的

静态代理：代理类和被代理类在编译期间就确定下来，且都实现同一个接口

静态代理是将被代理类的对象作为代理类的属性

![1596273882196](https://gitee.com/chrisxyq/picgo/raw/master/img/1596273882196.png)

动态代理是根据被代理类创建代理类

![1596273925187](https://gitee.com/chrisxyq/picgo/raw/master/img/1596273925187.png)

![1596271024199](https://gitee.com/chrisxyq/picgo/raw/master/img/1596271024199.png)



## **JDK 动态代理& CGLIB 动态代理**

动态代理是在运行时动态生成类字节码，并加载到 JVM 中的，

Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

|                              | JDK 动态代理                                                 | CGLIB 动态代理                                               |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代理对象                     | 只能代理实现了接口的类或者直接代理接口                       | 可以代理未实现任何接口的类   CGLIB(Code  Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成 |
| 核心原理                     | InvocationHandler 接口和 Proxy 类是核心                      | MethodInterceptor 接口和 Enhancer 类是核心                   |
| 使用步骤1：自定义方法拦截器 | JDK:    自定义方法拦截器InvocationHandler   并重写invoke方法：    CGLIB :自定义方法拦截器MethodInterceptor 并重写 intercept 方法 |                                                              |
| 使用步骤2： 获取代理对象   | JDK: 通过   Proxy.newProxyInstance(ClassLoader loader,Class<?>[]  interfaces,InvocationHandler h) 方法创建代理对象；    CGLIB : 通过 Enhancer 类的 create()创建代理类； |                                                              |
| 实际使用                     |                                                              |                                                              |
| 备注                         | invoke() 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。 | 通过生成一个被代理类的子类来拦截被代理类的方法调用，   因此不能代理声明为 final 类型的类和方法 |



|                                |                                                              |
| ------------------------------ | ------------------------------------------------------------ |
| JDK（Spring AOP 运行时增强）   | 接口，用Proxy.newProxyInstance生成代理对象，InvocationHandler |
| CGLIB（Spring AOP 运行时增强） | 用enhancer生成代理对象，MethodInteceptor   如果目标对象实现了接口，可以强制使用CGLIB实现AOP |
| AspectJ （编译时增强           | 切面太多的话，最好选择 AspectJ ，它比Spring   AOP 快很多     |
