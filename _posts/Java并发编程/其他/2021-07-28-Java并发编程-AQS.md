---
layout: post
title: AQS
catalog: true
tags:
    - Java并发编程

---

**AQS原理**(AbstractQueuedSynchronizer)

l 这个类在java.util.concurrent.locks包下面，AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。

l AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

**AQS加锁和解锁**









|      |      |
| ---- | ---- |
|      |      |
|      |      |



|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

**4.AbstractQueuedSynchronizer**

**AQS原理**

l 这个类在java.util.concurrent.locks包下面，AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。

l AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

**AQS加锁和解锁**



|      |
| ---- |
|      |
|      |
|      |

**！ConcurrentHashMap原理**

JDK1.8 （上面有示意图）

ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）

synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

**线程安全的ArrayList**

l Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类

l concurrent并发包下的CopyOnWriteArrayList类。



**6. 线程池**

**使用线程池的好处**

l 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

l 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

l 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

**线程池7大参数**

| corePoolSize   （线程池的基本大小）      | 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。      CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数，减少上下文切换  IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1，  而对于混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了 |
| ---------------------------------------- | ------------------------------------------------------------ |
| RunnableTaskQueue   （任务队列）         | 有几种类型                                                   |
| maximumPoolSize   （线程池最大数量）     | 如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务 |
| ThreadFactory                            | 创建线程的工厂                                               |
| RejectedExecutionHandler（四种拒绝策略） |                                                              |
| keepAliveTime                            | 当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁； |
| unit                                     | keepAliveTime 参数的时间单位                                 |

**ThreadPoolExecutor四种拒绝策略**

所有拒绝策略都实现了接口 RejectedExecutionHandler

| AbortPolicy（默认） | RejectedExecutionException来拒绝新任务的处理。 |
| ------------------- | ---------------------------------------------- |
| CallerRunsPolicy    | 只用调用者所在线程来运行任务。                 |
| DiscardOldestPolicy | 丢弃最早的未处理的任务请求，并执行当前任务。   |
| DiscardPolicy       | 不处理，丢弃掉。                               |

**四种线程池**

| CachedThreadPool     | 允许的创建线程数量为 Integer.MAX_VALUE   |
| -------------------- | ---------------------------------------- |
| FixedThreadPool      | 允许的请求队列长度为 Integer.MAX_VALUE   |
| ScheduledThreadPool  | 允许的创建线程数量为 Integer.MAX_VALUE   |
| SingleThreadExecutor | 允许的请求队列长度为   Integer.MAX_VALUE |

**execute()和 submit()的区别**

l execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；

l submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。

**ThreadPoolExecutor源码**

**5.** **Threadlocal**

| 概念                 | ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 |
| -------------------- | ------------------------------------------------------------ |
| 应用场景             | 保持dao对象是单例的，但是不把connection定义成dao的成员变量，而是定义成线程的变量。这样同一个线程的dao对象的所有方法都可以使用同一个connection, 并且connection不会有线程安全问题。而把把变量定义成线程的变量就是靠threadlocal来完成的。 |
| 代码举例             |                                                              |
| 内存泄漏   问题描述  | 在ThreadLocalMap中，entry的key是弱引用，value仍然是一个强引用。当某一条线程中的ThreadLocal使用完毕，没有强引用指向它的时候，这个key指向的对象就会被垃圾收集器回收，从而这个key就变成了null   所以entry就变成了(null,  value), 而entry 和 value 都是强引用，并且只要entry还在，value就一直存在。所以如果我们不手动清理掉这些键为空的entry， 在线程执行完毕之前，这个entry就一直处于内存泄漏的状态。线程生命周期越长，内存泄漏的就越多。 |
| 为什么要设置成弱引用 | 使用弱引用可以多一层保障：(null, value),对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。 |
| 解决内存泄漏         | 需要程序员在完成ThreadLocal的使用后要养成手动调用remove的习惯   ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。 |

**其他多线程问题**

**线程的6种状态**

![img](https://pic1.zhimg.com/v2-4f89913ab376925632be5823a038f938_b.png)

执行→就绪：yield()

**sleep和wait的区别**

|            | Sleep                                                        | Wait                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 是否释放锁 | 线程类（Thread）的方法，只让出了CPU，但监控依然保持，不会释放对象锁 | Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程 |
| 使用限制   | 可以在任何地方使用                                           | 只能在同步方法或同步块中使用   （notify/notifyAll和wait方法依赖于monitor对象，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor |
| 用途       | sleep() 通常被用于暂停执行                                   | wait() 通常被用于线程间交互/通信   不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法  或使用 wait(long timeout) 超时后线程会自动苏醒 |

**QPS每秒查询率(Query Per Second)**

l QPS每秒查询率(Query Per Second)

l 吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量就是响应时间的倒数。

**守护线程**

| 为何要用守护线程 | 我们知道静态变量是ClassLoader级别的，如果Web应用程序停止，这些静态变量也会从JVM中清除。但是线程则是JVM级别的，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使你停止了Web应用，这个线程依旧是活跃的。正是因为这个很隐晦   的问题，所以很多有经验的开发者不太赞成在Web应用中私自启动线程。 |
| ---------------- | ------------------------------------------------------------ |
| 用法             | daemonThread.setDaemon(true);                                |
| 举例             | l  守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者   l  消息推送线程设置为守护线程，服务于ChatServlet的servlet用户线程，在servlet的init启动消息线程，servlet一旦初始化后，一直存在服务器，servlet摧毁后,消息线程自动退出 |







