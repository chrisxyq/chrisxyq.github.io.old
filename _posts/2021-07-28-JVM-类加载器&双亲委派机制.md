---
layout: post
title: 类加载器&双亲委派机制
catalog: true
tags:
    - JVM

---



## 虚拟机自带的加载器

**1.2三种类加载器**

| 启动类加载器(Bootstrap ClassLoader)       | 负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类 |
| ----------------------------------------- | ------------------------------------------------------------ |
| 扩展类加载器(Extension ClassLoader)       | 负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库 |
| 应用程序类加载器(Application ClassLoader) | 加载用户路径（classpath）上的类库                            |
|                                           | 可以通过继承java.lang.ClassLoader实现自定义的类加载器        |

### 引导类加载器（bootstrap classloader

bootstrap classloader定义

![image-20210206095002713](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095002713.png)

查看bootstrap classloader所负责加载的class

如rt.jar下的string

![image-20210206095750085](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095750085.png)

![image-20210206095543593](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095543593.png)

查看某个类的类加载器

![image-20210206095826540](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095826540.png)

### 扩展类加载器

定义

![image-20210206095159807](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095159807.png)

查看扩展类加载器所负责加载的class

![image-20210206100257212](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206100257212.png)

![image-20210206100349545](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206100349545.png)

### 应用程序类加载器（appclassloader

![image-20210206095404422](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206095404422.png)

## 双亲委派机制

### 定义

在实际加载类之前，一直向上委托到顶层类加载器，然后逐个找可以加载该类的加载器

![image-20210206102611310](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206102611310.png)

类比：小孩吃苹果往长辈上面让，长辈先决定吃不吃

### 测试

![image-20210206103445604](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206103445604.png)

1.自定义一个string类，并添加静态代码块用于测试，new一个string是会加载rt下的string还是自定义的string

2.若执行上图的main，则会报错，因为加载的是rt下的string类，rt下的string类没有main方法

### 双亲委派机制优势

![image-20210206152910428](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206152910428.png)

1.沙箱安全机制保护源代码

![image-20210206153522887](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206153522887.png)

举例如下

若建立一个java.lang为名的包，在包下建立一个类string，由于引导类加载器负责加载java开头的类，因此将由引导类加载器找到并加载源码的string类

若一个java.lang为名的包，在包下建立一个类stshkstart，由于引导类加载器负责加载java开头的类，而引导类加载器找不到该类名，将报错prohibited package name

### 我自己写了一个java.lang.String类，怎么加载到jvm中？

**1.1双亲委派机制**

| 概念 | 当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。 |
| ---- | ------------------------------------------------------------ |
| 好处 | 比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。 |

**1.3!类加载过程**

加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。

装载：查找和导入Class文件。

链接：把类的二进制数据合并到JRE中。

校验：检查载入Class文件数据的正确性。

准备：给类的静态变量分配存储空间。

解析：将符号引用转成直接引用。

初始化：对类的静态变量，静态代码块执行初始化操作。

**1.4对象创建过程**

| 1.检查类是否加载   没有加载先加载类 |                                                              |
| ----------------------------------- | ------------------------------------------------------------ |
| 2.分配内存                          | l  如果开启了逃逸分析，jvm会先判断，是否可以在栈上分配，   l  在堆中分配内存有两种方式：1.指针碰撞法（内存空间比较规整） 2.空闲列表 |
| 3.初始化                            | 给实例对象的成员变量赋值为零值，引用类型为null，int类型赋值为0等等操作 |
| 4.设置对象头                        | 对象头包括   l  对象的hashcode、  l  线程、年龄、锁的状态  l  类在方法区的元数据信息  l  数组长度  l  对齐填充位 |
| 5.执行初始化方法                    |                                                              |

**1.5JVM对堆的优化：逃逸分析、标量替换、栈上分配**

| 逃逸分析 | l  即jvm判断对象会不会逃离某个方法，比如在某个方法中创建对象，方法执行完成后 对象就成了垃圾对象。如果判断对象并不会被外部访问，也就是未逃逸出方法   l  开启逃逸分析：-XX:+DoEscapeAnalysis |
| -------- | ------------------------------------------------------------ |
| 标量替换 | l  将对象的成员变量分解成若干个可以被方法使用的局部变量所代替，这些代替的局部变量在栈帧或寄存器中分配空间，这样就不会因为没有一大块连续的内存空间而导致无法在栈上分配   l  开启标量替换：-XX:+EliminateAllocations |
| 栈上分配 | jvm对内存的一种优化，减轻堆的压力，通过标量替换的方式，把对象肢解到栈上，只有同时开启逃逸分析和标量替换，对象才能成功在栈中分配 |