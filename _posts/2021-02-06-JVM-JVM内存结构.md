---
layout: post
title: JVM内存结构
catalog: true
tags:
    - JVM
---

视频来源：https://www.bilibili.com/video/BV1PJ411n7xZ

string a = "aa" 和 string b = new string("aa")区别，"aa"位置

概述

![image-20210206154238960](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206154238960.png)

![1596778795502](https://gitee.com/chrisxyq/picgo/raw/master/img/1596778795502.png)

栈和程序计数器不会有垃圾，否则main就崩了。所说的JVM调优主要指堆和方法区。



![1596363849164](https://gitee.com/chrisxyq/picgo/raw/master/img/1596363849164.png)

多线程共享堆和方法区，其余的是每个线程独有一份的。

字节码文件能执行，需要借助于执行引擎。执行引擎包括垃圾回收器。执行引擎是高级语言翻译成机器语言的执行者。

## 

# 运行时数据区

## 1.运行时数据区的介绍

引言：当我们通过类加载器，把类加载到内存中，存放在方法区的时候

厨师：执行引擎、食材：运行时数据区、编译字节码文件：炒菜、垃圾回收：清理台面

### 1.1结构如下

![image-20210206171315809](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206171315809.png)

### 1.2运行时数据区和线程

如下图所示：

线程间共享方法区method area和堆heap，每个线程有一份程序计数器pc、本地方法栈nms、虚拟机栈vms

![image-20210206172551732](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206172551732.png)

### 1.3关于runtime类的说明

一个jvm实例，对应一个runtime实例，单例的，可以通过getruntime()方法获取当前运行时类

三大重点：虚拟机栈、堆、方法区

1.4error和gc

|                     | 是否有error | 是否有gc |
| ------------------- | ----------- | -------- |
| 程序计数器          | ×           | ×        |
| 栈（虚拟机/本地方法 | √           | ×        |
| 堆                  | √           | √        |
| 方法区              | √           | √        |



## 2.jvm的pc寄存器

### 2.1pc寄存器概念

概念：是对物理pc寄存器的抽象模拟，又称为程序钩子，用于存储下一行指令的地址的

每个线程有一份程序寄存器，程序寄存器的生命周期与线程保持一致

![image-20210206182155156](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206182155156.png)

### 2.2pc寄存器作用

![image-20210206182904405](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206182904405.png)

## 3.虚拟机栈：用于管理java方法的调用

### 3.1概述

栈帧是栈的基本单位，包括如下内容

![image-20210206183455905](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206183455905.png)

通过-Xss设置栈的大小

### 3.2局部变量是否是线程安全的

判断方法：在该局部变量的生命周期内，有没有被多个线程同时操作的可能性

| 方法的形参                           | 线程不安全，多个线程均可操作该方法的形参           |
| ------------------------------------ | -------------------------------------------------- |
| 方法内声明的局部变量，且没有返回出去 | 线程安全，其生命周期在单个线程内创建和消亡         |
| 方法内声明的局部变量，且返回出去     | 线程不安全，作为返回值返回出去后，多个线程均可操作 |



## 4.本地方法栈：用于管理native本地方法的调用

本地方法栈也是线程私有的

### 4.1本地方法：native method

定义：

一个native method就是一个java语言调用非java代码的接口，从而方便与操作系统交互

native method举例：

object类的getclass()方法

lang.thread类的start0方法

## 5.堆

### 5.1堆的基本介绍

一个jvm在启动时创建一个堆区，所有线程共享，一个堆物理上可以处于不连续的空间中

堆有一部分小空间为线程私有的缓冲区TLAB

设置初始堆空间和最大堆空间

![image-20210206202056549](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206202056549.png)

使用jvisualvm工具观察进程的堆空间，堆空间等于以下四个区域的内存之和

![image-20210206202431485](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206202431485.png)

堆的基本介绍

![image-20210206235428788](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210206235428788.png)

堆的逻辑分类

![image-20210207000855022](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207000855022.png)

永久区/元空间属于方法区

![image-20210207002003051](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207002003051.png)

throwable类分为两个子类：error和exception

### 5.2新生代和老年代相关参数的设置

java对象可分为生命周期短的对象和生命周期长的对象

若生命周期对象长的对象偏多，则建议增加老年代的占比

![image-20210207002310618](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207002310618.png)

![image-20210207002629307](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207002629307.png)

要想新生代的比例是8:1:1，需要显式的进行如下指定

![image-20210207003034212](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207003034212.png)

### 5.3对象分配过程概述

![image-20210207003521689](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207003521689.png)

![image-20210207005222280](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207005222280.png)

![image-20210207005512459](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207005512459.png)

第一次minor gc：

当伊甸园区满的时候，通过minor gc和可达性算法判断垃圾，对垃圾进行垃圾回收，将伊甸园区的非垃圾放到幸存者区S0（from区）（对象有一个年龄计数器，每次当对象从伊甸园区进入幸存者区，对象年龄+1），因此伊甸园区被清空，可以再次放对象

第二次minor gc：

当伊甸园区又满的时候，将伊甸园区的非垃圾放到幸存者区S1（to区），并对幸存者区S0的对象进行垃圾判断，若不是垃圾，则放到幸存者区S1（to区），使得幸存者区S0（from区）清空

注：

- 每次gc之后，空的幸存者区域成为to区，被占用的幸存者区域成为from区域（to区即下一次gc的时候伊甸园区域的对象的去往地）

- 当年龄达到15，进入老年代
- 当整个伊甸园区都放不下对象时候，该对象直接进入老年代1

将对象分配过程的流程图总结如下

![image-20210207005801833](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207005801833.png)

### 5.4minor gc、major gc和full gc

gc在检索垃圾的时候，会触发stw（stop the world），暂停用户线程。因此jvm调优是为了降低gc频率，特别是major gc和full gc

![image-20210207010253960](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207010253960.png)

![image-20210207010355574](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207010355574.png)

注意:幸存者区满了之后的垃圾回收是被动的，他的触发条件是伊甸园区满了，触发垃圾回收时，顺便把幸存者区的垃圾进行回收

![image-20210207010747906](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207010747906.png)

![image-20210207010810595](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210207010810595.png)

### 5.5GC举例和日志分析

设置堆空间为9M，且显示GC详细信息

![image-20210211090514438](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210211090514438.png)

string字符串常量池是存在堆空间的（以前在方法区	

### 5.6为什么要对堆分代

老年代：存放新生代多次GC依旧存活的对象

![image-20210211092254756](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210211092254756.png)

### 5.7TLAB(thread local allocation buffer):JVM在伊甸园区为每个线程分配的私有缓存区域

尽管tlab仅占据伊甸园区的1%，却是内存分配的首选

### 5.8堆空间参数设置的指令总结

![image-20210211110749764](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210211110749764.png)

survivorratio比例的影响：

若survivorratio比例设置过大的话，则削弱了minorgc和分代的意义

由于minorgc触发条件是伊甸园区满，因此若survivorratio比例设置过小，则导致minorgc频率变高，导致stop the world频率变高

空间分配担保策略：minorgc之前的安全检查

![image-20210211112424505](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210211112424505.png)

### 5.9逃逸分析：将堆上的对象分配到栈上

![image-20210213102436272](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213102436272.png)

没有发生逃逸的对象，则可以分配到栈上，随着方法执行结束，栈空间就被移除（自动的内存释放

将对象分配到栈上，类似聚合量→标量的替换，即将对象打散为属性，存储在栈中

![image-20210213103015305](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213103015305.png)

结论：开发中，能使用局部变量分配的，就不要在方法外定义，从而线程回收，局部变量对象也被回收，就无需进行垃圾回收

### 5.10代码优化--同步省略/消除

![image-20210213210059775](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213210059775.png)

若同步监视器只能被一个线程访问，则在编译时，将忽略该同步监视器/锁

![image-20210213210457796](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213210457796.png)

## 6.方法区/元空间

### 6.1运行时数据区的分类

栈、堆、方法区

![image-20210213212107180](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213212107180.png)

### 6.2栈堆方法区的交互关系

![image-20210213222844418](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213222844418.png)

![image-20210213222903494](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213222903494.png)

### 6.3方法区的理解

多个线程共享某个类的时候，只需要由一个线程来加载classloader这个类即可

类加载都是放在方法区

方法区和堆的关系是台湾和大陆的关系

![image-20210213234527103](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213234527103.png)

![image-20210214002301645](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214002301645.png)

字符串常量池放在堆的原因：为了方便及时回收stringtable

![image-20210214002804790](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214002804790.png)

注：类的成员变量/属性，是在堆里面，类的方法的局部变量，是在栈里面

方法区溢出的示例场景

![image-20210213234950761](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210213234950761.png)

### 6.4方法区的运行时常量池

![image-20210214000439241](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214000439241.png)

运行时常量池：保存在方法区的常量池

字节码文件只存储指向常量池的引用，从而使得代码占用的内存较小，字节码文件通过#，调用常量池，示例如下

![image-20210214001104035](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214001104035.png)

### 6.5方法区的垃圾回收

![image-20210214005013951](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214005013951.png)

![image-20210214005350674](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214005350674.png)

## 7.对象

### 7.1创建对象的步骤

1.判断对象的类是否已经加载，加载对象的类

![image-20210214013223774](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214013223774.png)

![image-20210214013256733](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214013256733.png)

![image-20210214013318983](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214013318983.png)

### 7.2对象的内存布局：对象头、实例数据

![image-20210214013609644](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214013609644.png)

### 7.3热点代码探测确定何时JIT

![image-20210214014049710](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214014049710.png)

## 8.string

8.1

string在jdk1.9之前是char数组，jdk1.9及之后是byte数组+字符集的标识

一般使用一个byte、必要时（中文字符，使用两个byte/一个char

![image-20210214015237872](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214015237872.png)

字符串常量池

![image-20210214094134537](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210214094134537.png)





## 

