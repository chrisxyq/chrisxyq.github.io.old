---
layout: post
title: Thread
catalog: true
tags:
    - 多线程
---
视频来源：https://www.bilibili.com/video/BV1Kw411Z7dF



**Java内存模型**

| 可见性（volatile可保证）     | 当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值. |
| ---------------------------- | ------------------------------------------------------------ |
| 原子操作                     | 原子操作是指不会被线程调度机制打断的操作   只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作 |
| 顺序一致性（volatile可保证） | 防止 JVM 的指令重排                                          |

进程线程

进程：正在执行的程序，是资源调度的基本单位、每个进程有独立的内存区域（方法区和堆空间）

线程：一个程序内部的一条执行路径，每个线程有独立的虚拟机栈和程序计数器，一个进程的多个线程共享同一个堆和方法区、因此若一个进程有一个实例变量，多个线程都可进行访问修改、jvm调优即为对线程共享的区域（堆进行优化

相较于进程，同一进程的线程之间通信的方便之处，类似于合租室友访问同一个厨房进行交流

![image-20210117224738752](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117224738752.png)



## 线程的方法和优先级

![1596788027094](https://gitee.com/chrisxyq/picgo/raw/master/img/1596788027094.png)

注：yield方法释放当前线程的执行权，但有可能再次获得执行权

![1596787943764](https://gitee.com/chrisxyq/picgo/raw/master/img/1596787943764.png)

同一个进程的线程共享方法区和堆，每个线程有独立的虚拟机栈和程序计数器

子类中抛的异常不能比父类的大，父类没有抛异常，则子类重写的方法也不能抛异常。只能用try catch。

## 创建线程的四种方法

### 继承Thread类（new  MyThread().start()

![1590735086663](https://gitee.com/chrisxyq/picgo/raw/master/img/1590735086663.png)

使用示例

![image-20210117225724261](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117225724261.png)

匿名子类

![image-20210117230423014](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117230423014.png)

三个窗口卖票问题：如下实现有线程安全问题，即有重票/错票现象

![image-20210117232330012](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210117232330012.png)

若不想使用static，采用实现runnable接口的方式

### 实现Runnable接口（new Thread(runnable).start()

![1590735045476](https://gitee.com/chrisxyq/picgo/raw/master/img/1590735045476.png)

多窗口卖票示例

![1596790885120](https://gitee.com/chrisxyq/picgo/raw/master/img/1596790885120.png)

![1596790827293](https://gitee.com/chrisxyq/picgo/raw/master/img/1596790827293.png)

- window这个对象就是多个线程共享的数据，相较于继承的方式，ticket不用加static

- Thread类本身也是实现runnable接口的



### 实现Callable接口（new Thread(futureTask).start()

JDK5.0新特性的两种方法

![image-20210118001502562](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001502562.png)

![image-20210118001706204](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001706204.png)

futureTask的构造函数不止能接收callable、也能接收runnable和返回值

![image-20210801155222182](https://gitee.com/chrisxyq/picgo/raw/master/https://gitee.com/chrisxyq/image-20210801155222182.png)

使用示例

![image-20210118002842558](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118002842558.png)

futureTask对象的get方法，可以通过阻塞的方法获取异步任务的返回结果

![image-20210118002641713](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118002641713.png)

注：

futuretask的构造器需要传入一个实现callable接口的对象，即numthread

futuretask实现了runnable接口，因此可以作为构造器的参数传入thread类，以启动一个新的线程

futuretask和callable接口都支持泛型，以指定返回数据的类型

### 使用线程池

![1590761700714](https://gitee.com/chrisxyq/picgo/raw/master/img/1590761700714.png)

![image-20210118000825613](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118000825613.png)

使用示例

![image-20210118001253869](https://gitee.com/chrisxyq/picgo/raw/master/img/image-20210118001253869.png)



## 线程的五种状态/生命周期和线程通信

Thread的内部类State定义了线程的几种状态

![1596791611715](https://gitee.com/chrisxyq/picgo/raw/master/img/1596791611715.png)

![1596798231562](https://gitee.com/chrisxyq/picgo/raw/master/img/1596798231562.png)

- 运行到就绪：通过yield()暂时失去cpu的执行权，可能下一秒又获得执行权

- 阻塞到就绪：notify()唤醒当前的wait()阻塞状态的线程

- 运行到阻塞：wait()使得线程进入阻塞状态并且释放锁，sleep()使得线程进入阻塞状态但不会释放锁
- wait/notify、suspend/resume

![1590752697844](https://gitee.com/chrisxyq/picgo/raw/master/img/1590752697844.png)

![1590752867761](https://gitee.com/chrisxyq/picgo/raw/master/img/1590752867761.png)

|            | Sleep                                                        | Wait                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 是否释放锁 | 线程类（Thread）的方法，只让出了CPU，但监控依然保持，不会释放对象锁 | Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程 |
| 使用限制   | 可以在任何地方使用                                           | 只能在同步方法或同步块中使用   （notify/notifyAll和wait方法依赖于monitor对象，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor |
| 用途       | sleep() 通常被用于暂停执行                                   | wait() 通常被用于线程间交互/通信   不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法  或使用 wait(long timeout) 超时后线程会自动苏醒 |

## **在重写的run方法中，我们只能够进行异常的捕获而不能够抛出异常**

父类Runnable接口中，run方法没有抛出异常，则实现Runnable的子类就无法抛出异常（子类在重写父类方法时只能够抛出与父类相同的异常或者父类异常的子类）

Callable的call方法分可以抛出异常，而Runnable的run方法不能抛出异常

**守护线程**

| 为何要用守护线程 | 我们知道静态变量是ClassLoader级别的，如果Web应用程序停止，这些静态变量也会从JVM中清除。但是线程则是JVM级别的，如果你在Web 应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使你停止了Web应用，这个线程依旧是活跃的。正是因为这个很隐晦   的问题，所以很多有经验的开发者不太赞成在Web应用中私自启动线程。 |
| ---------------- | ------------------------------------------------------------ |
| 用法             | daemonThread.setDaemon(true);                                |
| 举例             | l  守护线程最典型的应用就是 GC (垃圾回收器)，它就是一个很称职的守护者   l  消息推送线程设置为守护线程，服务于ChatServlet的servlet用户线程，在servlet的init启动消息线程，servlet一旦初始化后，一直存在服务器，servlet摧毁后,消息线程自动退出 |
