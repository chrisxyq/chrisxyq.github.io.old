---
layout: post
title: redis基础
catalog: true
tags:
    - Redis
---

### **常用数据结构**

|               | 操作&应用场景                                                |
| ------------- | ------------------------------------------------------------ |
| string        | set,get,strlen,exists,decr,incr,setex   需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量 |
| list 双向链表 | rpush,lpop,lpush,rpop,lrange、llen   发布与订阅或者说消息队列、慢查询 |
| hash          | hset,hmset,hexists,hget,hgetall,hkeys,hvals   存储用户信息，商品信息 |
| set           | sadd,spop,smembers,sismember,scard,sinterstore,sunion   不能重复以及需要获取多个数据源交集和并集 |
| sorted set    | zadd,zcard,zscore,zrange,zrevrange,zrem   实时排行信息包含直播间在线用户列表，各种礼物排行榜 |
| bitmap        | setbit 、getbit 、bitcount、bitop   用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频） |
| Hyperloglog   |                                                              |

### **过期数据删除策略&内存淘汰机制**

| 过期数据删除策略                                             | 惰性删除（CPU 友好） ：只会在取出 key 的时候才对数据进行过期检查。 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定期删除（内存友好） ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。 |                                                              |
| 内存淘汰机制（还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况 | allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） |
| allkeys-lfu（least   frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key |                                                              |
| allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 |                                                              |
| volatile-lru（least   recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 |                                                              |
| volatile-lfu（least   frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰 |                                                              |
| volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 |                                                              |

### **持久化机制（挂掉之后再重启数据可以进行恢复）**

| 快照（snapshotting）持久化（RDB） | save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。   使用fork子进程，备份存储在内存里面的数据在某个时间点上的副本 | 间隔太久、安全性低                          |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------- |
| AOF（append-only   file）持久化   | 每秒同步/每修改同步   appendfsync everysec  #每秒钟同步一次， | 优先使用aof   安全但是文件大、效率没有rdb高 |
|                                   | Redis 4.0 开始支持   RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。     如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头 |                                             |

### **Redis事务**

Redis 是不支持 roll back 的，可以保证最终一致性

原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；

持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

| MULTI& EXEC   开始&执行 | 开始事务（MULTI）。   命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)。  执行事务(EXEC)。 |
| ----------------------- | ------------------------------------------------------------ |
| DISCARD    取消         | 取消一个事务，清空事务队列中保存的所有命令                   |
| WATCH   监听指定的键    | > WATCH USER   OK  > MULTI  > SET USER "Guide哥"  OK  > GET USER  Guide哥  > EXEC  ERR EXEC without MULTI |

### **缓存穿透&雪崩**

|      | 缓存穿透                                                     | 缓存雪崩                                                     | 缓存击穿                             |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------ |
| 概念 | 大量恶意请求的 key 根本不存在于缓存和数据库中                | 热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上 | 缓存没有、数据库有   高并发导致      |
| 解决 | 保存到redis+布隆过滤器bitmap   如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，这种方式可以解决请求的 key 变化不频繁的情况  布隆过滤器说某个元素不在，那么这个元素一定不在 | 设置随机失效时间+限流   设置不同的失效时间比如随机设置缓存的失效时间。  限流，避免同时处理大量的请求。 | 热点数据设置永不过期   互斥锁cas自旋 |

### **Cache Aside Pattern（旁路缓存模式）：缓存数据库一致性**

如果更新数据库成功，而删除缓存失败：

增加 cache 更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。

### **Redis**

#### **1.** **AOF备份文件过大怎么办**

Bgrewriteaof 命令用于异步执行一个 AOF（AppendOnly File） 文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本

|                     |                                                              |
| ------------------- | ------------------------------------------------------------ |
| RDB   快照/定时     | fork子进程   指定的时间间隔内将内存中的数据集快照写入磁盘  save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。 |
| AOF   每秒/每次修改 | 以日志的形式记录服务器所处理的每一个写、删除操作   appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。 |

#### **2.** **redis 集群是怎么做到一致性的？**

#### **3.** **如何在缓存中只存储热点数据**

#### **4.** **zset 底层，为什么用压缩列表（避免内存碎片），跳表查询复杂度？**

#### **5.**Redisson的Lock底层实现
